// Code generated by tinyjson for marshaling/unmarshaling. DO NOT EDIT.

package testing

import (
	json "encoding/json"

	tinyjson "github.com/CosmWasm/tinyjson"
	jlexer "github.com/CosmWasm/tinyjson/jlexer"
	jwriter "github.com/CosmWasm/tinyjson/jwriter"
)

// suppress unused package warning
var (
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ tinyjson.Marshaler
)

func tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing(in *jlexer.Lexer, out *expectedOutput) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "headers":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Headers = make(map[string]string)
				} else {
					out.Headers = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v1 string
					v1 = string(in.String())
					(out.Headers)[key] = v1
					in.WantComma()
				}
				in.Delim('}')
			}
		case "data":
			out.Data = string(in.String())
		case "log_contains":
			out.LogContains = string(in.String())
		case "no_log_contains":
			out.NoLogContains = string(in.String())
		case "expect_error":
			out.ExpectError = bool(in.Bool())
		case "triggered_rules":
			if in.IsNull() {
				in.Skip()
				out.TriggeredRules = nil
			} else {
				in.Delim('[')
				if out.TriggeredRules == nil {
					if !in.IsDelim(']') {
						out.TriggeredRules = make([]int, 0, 8)
					} else {
						out.TriggeredRules = []int{}
					}
				} else {
					out.TriggeredRules = (out.TriggeredRules)[:0]
				}
				for !in.IsDelim(']') {
					var v2 int
					v2 = int(in.Int())
					out.TriggeredRules = append(out.TriggeredRules, v2)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "non_triggered_rules":
			if in.IsNull() {
				in.Skip()
				out.NonTriggeredRules = nil
			} else {
				in.Delim('[')
				if out.NonTriggeredRules == nil {
					if !in.IsDelim(']') {
						out.NonTriggeredRules = make([]int, 0, 8)
					} else {
						out.NonTriggeredRules = []int{}
					}
				} else {
					out.NonTriggeredRules = (out.NonTriggeredRules)[:0]
				}
				for !in.IsDelim(']') {
					var v3 int
					v3 = int(in.Int())
					out.NonTriggeredRules = append(out.NonTriggeredRules, v3)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "status":
			if m, ok := out.Status.(tinyjson.Unmarshaler); ok {
				m.UnmarshalTinyJSON(in)
			} else if m, ok := out.Status.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Status = in.Interface()
			}
		case "interruption":
			if in.IsNull() {
				in.Skip()
				out.Interruption = nil
			} else {
				if out.Interruption == nil {
					out.Interruption = new(expectedInterruption)
				}
				(*out.Interruption).UnmarshalTinyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing(out *jwriter.Writer, in expectedOutput) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Headers) != 0 {
		const prefix string = ",\"headers\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('{')
			v4First := true
			for v4Name, v4Value := range in.Headers {
				if v4First {
					v4First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v4Name))
				out.RawByte(':')
				out.String(string(v4Value))
			}
			out.RawByte('}')
		}
	}
	if in.Data != "" {
		const prefix string = ",\"data\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Data))
	}
	if in.LogContains != "" {
		const prefix string = ",\"log_contains\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.LogContains))
	}
	if in.NoLogContains != "" {
		const prefix string = ",\"no_log_contains\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.NoLogContains))
	}
	if in.ExpectError {
		const prefix string = ",\"expect_error\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.ExpectError))
	}
	if len(in.TriggeredRules) != 0 {
		const prefix string = ",\"triggered_rules\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v5, v6 := range in.TriggeredRules {
				if v5 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v6))
			}
			out.RawByte(']')
		}
	}
	if len(in.NonTriggeredRules) != 0 {
		const prefix string = ",\"non_triggered_rules\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v7, v8 := range in.NonTriggeredRules {
				if v7 > 0 {
					out.RawByte(',')
				}
				out.Int(int(v8))
			}
			out.RawByte(']')
		}
	}
	if in.Status != nil {
		const prefix string = ",\"status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if m, ok := in.Status.(tinyjson.Marshaler); ok {
			m.MarshalTinyJSON(out)
		} else if m, ok := in.Status.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Status))
		}
	}
	if in.Interruption != nil {
		const prefix string = ",\"interruption\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.Interruption).MarshalTinyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v expectedOutput) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v expectedOutput) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *expectedOutput) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *expectedOutput) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing(l, v)
}
func tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing1(in *jlexer.Lexer, out *expectedInterruption) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "rule_id":
			out.RuleID = int(in.Int())
		case "action":
			out.Action = string(in.String())
		case "status":
			out.Status = int(in.Int())
		case "data":
			out.Data = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing1(out *jwriter.Writer, in expectedInterruption) {
	out.RawByte('{')
	first := true
	_ = first
	if in.RuleID != 0 {
		const prefix string = ",\"rule_id\":"
		first = false
		out.RawString(prefix[1:])
		out.Int(int(in.RuleID))
	}
	if in.Action != "" {
		const prefix string = ",\"action\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Action))
	}
	if in.Status != 0 {
		const prefix string = ",\"status\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Status))
	}
	if in.Data != "" {
		const prefix string = ",\"data\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Data))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v expectedInterruption) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v expectedInterruption) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *expectedInterruption) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing1(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *expectedInterruption) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing1(l, v)
}
func tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing2(in *jlexer.Lexer, out *Profile) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "rules":
			out.Rules = string(in.String())
		case "Pass":
			out.Pass = bool(in.Bool())
		case "meta":
			tinyjson8028cee1Decode(in, &out.Meta)
		case "tinygo_disable":
			out.TinyGoDisable = bool(in.Bool())
		case "tests":
			if in.IsNull() {
				in.Skip()
				out.Tests = nil
			} else {
				in.Delim('[')
				if out.Tests == nil {
					if !in.IsDelim(']') {
						out.Tests = make([]struct {
							Title       string `json:"test_title,omitempty"`
							Description string `json:"desc,omitempty"`
							Stages      []struct {
								Stage struct {
									Input struct {
										DestAddr       string            `json:"dest_addr,omitempty"`
										Port           int               `json:"port,omitempty"`
										Method         string            `json:"method,omitempty"`
										URI            string            `json:"uri,omitempty"`
										Version        string            `json:"version,omitempty"`
										Data           string            `json:"data,omitempty"`
										Headers        map[string]string `json:"headers,omitempty"`
										RawRequest     []uint8           `json:"raw_request,omitempty"`
										EncodedRequest string            `json:"encoded_request,omitempty"`
										StopMagic      bool              `json:"stop_magic,omitempty"`
									} `json:"input,omitempty"`
									Output expectedOutput `json:"output,omitempty"`
								} `json:"stage,omitempty"`
							} `json:"stages,omitempty"`
						}, 0, 1)
					} else {
						out.Tests = []struct {
							Title       string `json:"test_title,omitempty"`
							Description string `json:"desc,omitempty"`
							Stages      []struct {
								Stage struct {
									Input struct {
										DestAddr       string            `json:"dest_addr,omitempty"`
										Port           int               `json:"port,omitempty"`
										Method         string            `json:"method,omitempty"`
										URI            string            `json:"uri,omitempty"`
										Version        string            `json:"version,omitempty"`
										Data           string            `json:"data,omitempty"`
										Headers        map[string]string `json:"headers,omitempty"`
										RawRequest     []uint8           `json:"raw_request,omitempty"`
										EncodedRequest string            `json:"encoded_request,omitempty"`
										StopMagic      bool              `json:"stop_magic,omitempty"`
									} `json:"input,omitempty"`
									Output expectedOutput `json:"output,omitempty"`
								} `json:"stage,omitempty"`
							} `json:"stages,omitempty"`
						}{}
					}
				} else {
					out.Tests = (out.Tests)[:0]
				}
				for !in.IsDelim(']') {
					var v9 struct {
						Title       string `json:"test_title,omitempty"`
						Description string `json:"desc,omitempty"`
						Stages      []struct {
							Stage struct {
								Input struct {
									DestAddr       string            `json:"dest_addr,omitempty"`
									Port           int               `json:"port,omitempty"`
									Method         string            `json:"method,omitempty"`
									URI            string            `json:"uri,omitempty"`
									Version        string            `json:"version,omitempty"`
									Data           string            `json:"data,omitempty"`
									Headers        map[string]string `json:"headers,omitempty"`
									RawRequest     []uint8           `json:"raw_request,omitempty"`
									EncodedRequest string            `json:"encoded_request,omitempty"`
									StopMagic      bool              `json:"stop_magic,omitempty"`
								} `json:"input,omitempty"`
								Output expectedOutput `json:"output,omitempty"`
							} `json:"stage,omitempty"`
						} `json:"stages,omitempty"`
					}
					tinyjson8028cee1Decode1(in, &v9)
					out.Tests = append(out.Tests, v9)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing2(out *jwriter.Writer, in Profile) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Rules != "" {
		const prefix string = ",\"rules\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Rules))
	}
	{
		const prefix string = ",\"Pass\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Pass))
	}
	if true {
		const prefix string = ",\"meta\":"
		out.RawString(prefix)
		tinyjson8028cee1Encode(out, in.Meta)
	}
	if in.TinyGoDisable {
		const prefix string = ",\"tinygo_disable\":"
		out.RawString(prefix)
		out.Bool(bool(in.TinyGoDisable))
	}
	if len(in.Tests) != 0 {
		const prefix string = ",\"tests\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v10, v11 := range in.Tests {
				if v10 > 0 {
					out.RawByte(',')
				}
				tinyjson8028cee1Encode1(out, v11)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Profile) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v Profile) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjson8028cee1EncodeGithubComCorazawafCorazaV3Testing2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Profile) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing2(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *Profile) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjson8028cee1DecodeGithubComCorazawafCorazaV3Testing2(l, v)
}
func tinyjson8028cee1Decode1(in *jlexer.Lexer, out *struct {
	Title       string `json:"test_title,omitempty"`
	Description string `json:"desc,omitempty"`
	Stages      []struct {
		Stage struct {
			Input struct {
				DestAddr       string            `json:"dest_addr,omitempty"`
				Port           int               `json:"port,omitempty"`
				Method         string            `json:"method,omitempty"`
				URI            string            `json:"uri,omitempty"`
				Version        string            `json:"version,omitempty"`
				Data           string            `json:"data,omitempty"`
				Headers        map[string]string `json:"headers,omitempty"`
				RawRequest     []uint8           `json:"raw_request,omitempty"`
				EncodedRequest string            `json:"encoded_request,omitempty"`
				StopMagic      bool              `json:"stop_magic,omitempty"`
			} `json:"input,omitempty"`
			Output expectedOutput `json:"output,omitempty"`
		} `json:"stage,omitempty"`
	} `json:"stages,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "test_title":
			out.Title = string(in.String())
		case "desc":
			out.Description = string(in.String())
		case "stages":
			if in.IsNull() {
				in.Skip()
				out.Stages = nil
			} else {
				in.Delim('[')
				if out.Stages == nil {
					if !in.IsDelim(']') {
						out.Stages = make([]struct {
							Stage struct {
								Input struct {
									DestAddr       string            `json:"dest_addr,omitempty"`
									Port           int               `json:"port,omitempty"`
									Method         string            `json:"method,omitempty"`
									URI            string            `json:"uri,omitempty"`
									Version        string            `json:"version,omitempty"`
									Data           string            `json:"data,omitempty"`
									Headers        map[string]string `json:"headers,omitempty"`
									RawRequest     []uint8           `json:"raw_request,omitempty"`
									EncodedRequest string            `json:"encoded_request,omitempty"`
									StopMagic      bool              `json:"stop_magic,omitempty"`
								} `json:"input,omitempty"`
								Output expectedOutput `json:"output,omitempty"`
							} `json:"stage,omitempty"`
						}, 0, 0)
					} else {
						out.Stages = []struct {
							Stage struct {
								Input struct {
									DestAddr       string            `json:"dest_addr,omitempty"`
									Port           int               `json:"port,omitempty"`
									Method         string            `json:"method,omitempty"`
									URI            string            `json:"uri,omitempty"`
									Version        string            `json:"version,omitempty"`
									Data           string            `json:"data,omitempty"`
									Headers        map[string]string `json:"headers,omitempty"`
									RawRequest     []uint8           `json:"raw_request,omitempty"`
									EncodedRequest string            `json:"encoded_request,omitempty"`
									StopMagic      bool              `json:"stop_magic,omitempty"`
								} `json:"input,omitempty"`
								Output expectedOutput `json:"output,omitempty"`
							} `json:"stage,omitempty"`
						}{}
					}
				} else {
					out.Stages = (out.Stages)[:0]
				}
				for !in.IsDelim(']') {
					var v12 struct {
						Stage struct {
							Input struct {
								DestAddr       string            `json:"dest_addr,omitempty"`
								Port           int               `json:"port,omitempty"`
								Method         string            `json:"method,omitempty"`
								URI            string            `json:"uri,omitempty"`
								Version        string            `json:"version,omitempty"`
								Data           string            `json:"data,omitempty"`
								Headers        map[string]string `json:"headers,omitempty"`
								RawRequest     []uint8           `json:"raw_request,omitempty"`
								EncodedRequest string            `json:"encoded_request,omitempty"`
								StopMagic      bool              `json:"stop_magic,omitempty"`
							} `json:"input,omitempty"`
							Output expectedOutput `json:"output,omitempty"`
						} `json:"stage,omitempty"`
					}
					tinyjson8028cee1Decode2(in, &v12)
					out.Stages = append(out.Stages, v12)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1Encode1(out *jwriter.Writer, in struct {
	Title       string `json:"test_title,omitempty"`
	Description string `json:"desc,omitempty"`
	Stages      []struct {
		Stage struct {
			Input struct {
				DestAddr       string            `json:"dest_addr,omitempty"`
				Port           int               `json:"port,omitempty"`
				Method         string            `json:"method,omitempty"`
				URI            string            `json:"uri,omitempty"`
				Version        string            `json:"version,omitempty"`
				Data           string            `json:"data,omitempty"`
				Headers        map[string]string `json:"headers,omitempty"`
				RawRequest     []uint8           `json:"raw_request,omitempty"`
				EncodedRequest string            `json:"encoded_request,omitempty"`
				StopMagic      bool              `json:"stop_magic,omitempty"`
			} `json:"input,omitempty"`
			Output expectedOutput `json:"output,omitempty"`
		} `json:"stage,omitempty"`
	} `json:"stages,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Title != "" {
		const prefix string = ",\"test_title\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Title))
	}
	if in.Description != "" {
		const prefix string = ",\"desc\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Description))
	}
	if len(in.Stages) != 0 {
		const prefix string = ",\"stages\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v13, v14 := range in.Stages {
				if v13 > 0 {
					out.RawByte(',')
				}
				tinyjson8028cee1Encode2(out, v14)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func tinyjson8028cee1Decode2(in *jlexer.Lexer, out *struct {
	Stage struct {
		Input struct {
			DestAddr       string            `json:"dest_addr,omitempty"`
			Port           int               `json:"port,omitempty"`
			Method         string            `json:"method,omitempty"`
			URI            string            `json:"uri,omitempty"`
			Version        string            `json:"version,omitempty"`
			Data           string            `json:"data,omitempty"`
			Headers        map[string]string `json:"headers,omitempty"`
			RawRequest     []uint8           `json:"raw_request,omitempty"`
			EncodedRequest string            `json:"encoded_request,omitempty"`
			StopMagic      bool              `json:"stop_magic,omitempty"`
		} `json:"input,omitempty"`
		Output expectedOutput `json:"output,omitempty"`
	} `json:"stage,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "stage":
			tinyjson8028cee1Decode3(in, &out.Stage)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1Encode2(out *jwriter.Writer, in struct {
	Stage struct {
		Input struct {
			DestAddr       string            `json:"dest_addr,omitempty"`
			Port           int               `json:"port,omitempty"`
			Method         string            `json:"method,omitempty"`
			URI            string            `json:"uri,omitempty"`
			Version        string            `json:"version,omitempty"`
			Data           string            `json:"data,omitempty"`
			Headers        map[string]string `json:"headers,omitempty"`
			RawRequest     []uint8           `json:"raw_request,omitempty"`
			EncodedRequest string            `json:"encoded_request,omitempty"`
			StopMagic      bool              `json:"stop_magic,omitempty"`
		} `json:"input,omitempty"`
		Output expectedOutput `json:"output,omitempty"`
	} `json:"stage,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if true {
		const prefix string = ",\"stage\":"
		first = false
		out.RawString(prefix[1:])
		tinyjson8028cee1Encode3(out, in.Stage)
	}
	out.RawByte('}')
}
func tinyjson8028cee1Decode3(in *jlexer.Lexer, out *struct {
	Input struct {
		DestAddr       string            `json:"dest_addr,omitempty"`
		Port           int               `json:"port,omitempty"`
		Method         string            `json:"method,omitempty"`
		URI            string            `json:"uri,omitempty"`
		Version        string            `json:"version,omitempty"`
		Data           string            `json:"data,omitempty"`
		Headers        map[string]string `json:"headers,omitempty"`
		RawRequest     []uint8           `json:"raw_request,omitempty"`
		EncodedRequest string            `json:"encoded_request,omitempty"`
		StopMagic      bool              `json:"stop_magic,omitempty"`
	} `json:"input,omitempty"`
	Output expectedOutput `json:"output,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "input":
			tinyjson8028cee1Decode4(in, &out.Input)
		case "output":
			(out.Output).UnmarshalTinyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1Encode3(out *jwriter.Writer, in struct {
	Input struct {
		DestAddr       string            `json:"dest_addr,omitempty"`
		Port           int               `json:"port,omitempty"`
		Method         string            `json:"method,omitempty"`
		URI            string            `json:"uri,omitempty"`
		Version        string            `json:"version,omitempty"`
		Data           string            `json:"data,omitempty"`
		Headers        map[string]string `json:"headers,omitempty"`
		RawRequest     []uint8           `json:"raw_request,omitempty"`
		EncodedRequest string            `json:"encoded_request,omitempty"`
		StopMagic      bool              `json:"stop_magic,omitempty"`
	} `json:"input,omitempty"`
	Output expectedOutput `json:"output,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if true {
		const prefix string = ",\"input\":"
		first = false
		out.RawString(prefix[1:])
		tinyjson8028cee1Encode4(out, in.Input)
	}
	if true {
		const prefix string = ",\"output\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.Output).MarshalTinyJSON(out)
	}
	out.RawByte('}')
}
func tinyjson8028cee1Decode4(in *jlexer.Lexer, out *struct {
	DestAddr       string            `json:"dest_addr,omitempty"`
	Port           int               `json:"port,omitempty"`
	Method         string            `json:"method,omitempty"`
	URI            string            `json:"uri,omitempty"`
	Version        string            `json:"version,omitempty"`
	Data           string            `json:"data,omitempty"`
	Headers        map[string]string `json:"headers,omitempty"`
	RawRequest     []uint8           `json:"raw_request,omitempty"`
	EncodedRequest string            `json:"encoded_request,omitempty"`
	StopMagic      bool              `json:"stop_magic,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "dest_addr":
			out.DestAddr = string(in.String())
		case "port":
			out.Port = int(in.Int())
		case "method":
			out.Method = string(in.String())
		case "uri":
			out.URI = string(in.String())
		case "version":
			out.Version = string(in.String())
		case "data":
			out.Data = string(in.String())
		case "headers":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Headers = make(map[string]string)
				} else {
					out.Headers = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v15 string
					v15 = string(in.String())
					(out.Headers)[key] = v15
					in.WantComma()
				}
				in.Delim('}')
			}
		case "raw_request":
			if in.IsNull() {
				in.Skip()
				out.RawRequest = nil
			} else {
				out.RawRequest = in.Bytes()
			}
		case "encoded_request":
			out.EncodedRequest = string(in.String())
		case "stop_magic":
			out.StopMagic = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1Encode4(out *jwriter.Writer, in struct {
	DestAddr       string            `json:"dest_addr,omitempty"`
	Port           int               `json:"port,omitempty"`
	Method         string            `json:"method,omitempty"`
	URI            string            `json:"uri,omitempty"`
	Version        string            `json:"version,omitempty"`
	Data           string            `json:"data,omitempty"`
	Headers        map[string]string `json:"headers,omitempty"`
	RawRequest     []uint8           `json:"raw_request,omitempty"`
	EncodedRequest string            `json:"encoded_request,omitempty"`
	StopMagic      bool              `json:"stop_magic,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if in.DestAddr != "" {
		const prefix string = ",\"dest_addr\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.DestAddr))
	}
	if in.Port != 0 {
		const prefix string = ",\"port\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Port))
	}
	if in.Method != "" {
		const prefix string = ",\"method\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Method))
	}
	if in.URI != "" {
		const prefix string = ",\"uri\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.URI))
	}
	if in.Version != "" {
		const prefix string = ",\"version\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Version))
	}
	if in.Data != "" {
		const prefix string = ",\"data\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Data))
	}
	if len(in.Headers) != 0 {
		const prefix string = ",\"headers\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v17First := true
			for v17Name, v17Value := range in.Headers {
				if v17First {
					v17First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v17Name))
				out.RawByte(':')
				out.String(string(v17Value))
			}
			out.RawByte('}')
		}
	}
	if len(in.RawRequest) != 0 {
		const prefix string = ",\"raw_request\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Base64Bytes(in.RawRequest)
	}
	if in.EncodedRequest != "" {
		const prefix string = ",\"encoded_request\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.EncodedRequest))
	}
	if in.StopMagic {
		const prefix string = ",\"stop_magic\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.StopMagic))
	}
	out.RawByte('}')
}
func tinyjson8028cee1Decode(in *jlexer.Lexer, out *struct {
	Author      string `json:"author,omitempty"`
	Description string `json:"description,omitempty"`
	Enabled     bool   `json:"enabled,omitempty"`
	Name        string `json:"name,omitempty"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "author":
			out.Author = string(in.String())
		case "description":
			out.Description = string(in.String())
		case "enabled":
			out.Enabled = bool(in.Bool())
		case "name":
			out.Name = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjson8028cee1Encode(out *jwriter.Writer, in struct {
	Author      string `json:"author,omitempty"`
	Description string `json:"description,omitempty"`
	Enabled     bool   `json:"enabled,omitempty"`
	Name        string `json:"name,omitempty"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Author != "" {
		const prefix string = ",\"author\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Author))
	}
	if in.Description != "" {
		const prefix string = ",\"description\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Description))
	}
	if in.Enabled {
		const prefix string = ",\"enabled\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Enabled))
	}
	if in.Name != "" {
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	out.RawByte('}')
}
